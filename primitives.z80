defcode "EXIT",4,0,EXIT
	POP_RET H,L		            ; POP_PAR0 return stack into IP
    NEXT_1

; FIND                                  ( ptr len -- headPtr )
defcode "FIND",4,0,FIND
    SAVE_REGS BC
    POP_PAR0 HL
    call lookup                     ; params: HL = string address, BC = string length
                                    ; returns: DE = found header ptr or 0
    RESTORE_REGS DE
    NEXT

defcode "EXECUTE",7,0,EXECUTE
    POP_PAR H,L                     ; POP TOS into HL
    jp (hl)                         ; go do Forth word

defcode "NUMBER",6,0,NUMBER             ; ( ptr len -- num err )
    SAVE_REGS BC
    POP_PAR0 HL
	call toNumber                   ; params: HL = string address, BC = string length
			                        ; Returns the parsed number in DE,
	                                ; BC = 0, success
    PUSH_PAR0 DE
    RESTORE_REGS BC
    NEXT

defcode "PRINT",5,0,PRINT
    SAVE_REGS DE
    call printPStr
    RESTORE_REGS0
    NEXT

defcode "TOKEN",5,0,TOKEN               ; -- c-addr length  ; NOT STANDARD
    PUSH_PAR0 BC                         ; save TOS
    exx
    call getToken
    PUSH_PAR0 DE                         ; DE = str ptr
    RESTORE_REGS BC                 ; HL = length
    NEXT

defcode "+!",2,0,ADDSTORE               ; (n addr -- )
	POP_PAR H, L		            ; HL = address, TOS = amount to add
	ld A,(HL)
	add A,C                         ; add TOS at (HL),
	ld (HL),A
	inc HL
	ld A,(HL)
	adc A,B
	ld (HL),A
	POP_PAR0 BC                      ; clear param stack
    NEXT

defcode "[",1,MSK_IMMED,LBRAC
	ld HL, 0
	ld (VAR_STATE), HL	; Set STATE to 0.
    NEXT

defcode "]",1,0,RBRAC
	ld HL, 1
	ld (VAR_STATE), HL	; Set STATE to 1.
    NEXT

defcode "HIDDEN",6,0,HIDDEN
    POP_PAR H,L		            ; HL = Dictionary entry.
    inc HL
    inc HL                      ; Point to name/flags byte.

    ld A, (HL)
    xor MSK_HIDDEN        	    ; Toggle the HIDDEN bit.
    ld (HL), A
    NEXT

; 1+      n1/u1 -- n2/u2            add 1 to TOS
defcode "1+",2,0,ONEPLUS
    inc BC
    NEXT

; 2+      n1/u1 -- n2/u2            add 2 to TOS
defcode "2+",2,0,TWOPLUS
    inc BC
    inc BC
    NEXT

; 1*      n1/u1 -- n2/u2            do nothing
defcode "NOOP",4,0,noop
    NEXT

defcode "BRANCH",6,0,BRANCH          ; relative branching
    ex DE, HL                   ; add the offset to the instruction pointer
    ld E, (HL)
    inc HL
    ld D, (HL)
    dec HL
    add HL, DE
    NEXT_1

; ?branch   x --              branch if TOS zero
defcode "0BRANCH",7,0,ZBRANCH
    ISZERO16 B,C        ; test old TOS
    POP_PAR0 BC              ; POP new TOS
    jr z,BRANCH         ; if old TOS=0, branch
    inc DE              ; else skip inline value
    inc DE
    NEXT

; U*   u1 u2 -- ud   unsigned mutliply
defcode "U*",2,0,UMUL  ; u1 u2 -- ud
    SAVE_REGS BC    ; u2 in BC
    POP_PAR0 DE          ; u1 in DE
	call unsignedMultiply
    PUSH_PAR0 DE         ; udlo result
    RESTORE_REGS BC ; udhi result
    NEXT

;C 0<     n -- flag      true if TOS negative
defcode "0<",2,0,ZEROLESS
    sla b           ; sign bit -> cy flag
    sbc a,a         ;
    and 1            ; <0 = -1, >0 = 0
    ld b,0
    ld c,a
    NEXT

defcode "LIT",3,0,LIT

	; IP points to the next command, But in this case it points to the next
	; literal 16 bit integer.  Get that literal increment IP.

	PUSH_PAR0 BC         ; pushTOS
	ex DE, HL       ; HL = IP
	ld C, (HL)      ; TOS = (IP), IP + 2
	inc HL
	ld B, (HL)
	inc HL
    NEXT_1

;z RSP!  a-addr --                  set return stack pointer
defcode "RSP!",4,0,RSPSTORE
	PUSH_PAR0 BC
	POP_PAR0 IX                      ; RSP = TOS
	POP_PAR0 BC                      ; POP TOS
    NEXT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; memory access
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; !        x a-addr --   store cell in memory
defcode "!",1,0,STORE
    POP_PAR H,L
    ld (HL),C
    inc HL
    ld (HL),B
    POP_PAR0 BC          ; POP new TOS
    NEXT

defcode ",",1,0,COMMA
	ld HL, (VAR_HERE)	; HERE
	ld (HL), C          ; Store DE at memory pointed to by VAR_HERE
	inc HL
	ld (HL), B
	inc HL
	ld (VAR_HERE), HL	; Update HERE (incremented)
	POP_PAR0 BC		        ; cleanup TOS
    NEXT

defcode "@",1,0,FETCH
    LOAD16 H,L, B,C ; HL = TOS
	ld C, (HL)      ; TOS = (HL)
	inc HL
	ld B, (HL)
    NEXT

; CELL+    c-addr1 -- c-addr2   add cell size to addr
defcode "CELL+",5,0,CELLPLUS
    jp twoplus

; CELLS   ( n1 -- n2 ) n2 is the size in address units of n1 cells.
defcode "CELLS",5,0,CELLS
    jp twostar

; C!      char c-addr --    store char in memory
defcode "C!",2,0,CSTORE
    POP_PAR H,L
    ld (HL),C
    POP_PAR0 BC          ; POP new TOS
    NEXT

defcode "C,",1,0,CCOMMA
    PUSH_PAR0 HL
	ld HL, (VAR_HERE)	; HERE
	ld (HL), C          ; Store DE at memory pointed to by VAR_HERE
	inc HL
	ld (VAR_HERE), HL	; Update HERE (incremented)
    POP_PAR0 HL
	POP_PAR0 BC		        ; cleanup TOS
    NEXT

; C@     c-addr -- char   fetch char from memory
defcode "C@",2,0,CFETCH
    ld A,(BC)
    ld C,A
    ld B,0
    NEXT

; CHAR+    c-addr1 -- c-addr2   add char size to addr
defcode "CHAR+",5,0,CHARPLUS
    jp oneplus

; CELLS   ( n1 -- n2 ) n2 is the size in address units of n1 cells.
defcode "CHARS",5,0,CHARS
    jp noop


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; arithmetic
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; */MOD star-slash-mod

; +       n1/u1 n2/u2 -- n3/u3     add n1+n2
defcode "+",1,0,PLUS
    POP_PAR0 HL
    add HL,BC
    LOAD16 B,C, H,L
    NEXT

; 2*      n1/u1 -- n2/u2            arithmetic left shift
defcode "2*",2,0,TWOSTAR
    sla C
    rl B
    NEXT

defcode "-",1,0,MINUS
    POP_PAR0 HL
    or A
    sbc HL,BC
    LOAD16 B,C, H,L
    NEXT

; U/MOD   ud u1 -- u2 u3   unsigned 32/16->16
defcode "U/MOD",5,0,USLASHMOD
    SAVE_REGS BC    ; BC = divisor
    POP_PAR0 HL      ; HLDE = dividend
    POP_PAR0 DE
    call unsignedSlashMod
    PUSH_PAR0 HL     ; PUSH remainder
    RESTORE_REGS BC     ; quotient remains in TOS
    NEXT

; 2/      x1 -- x2                  arithmetic right shift
defcode "2/",2,0,TWOSLASH
    sra B
    rr C
    NEXT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; logic
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 0= zero-equals
defcode "0=",2,0,ZEQUAL
    ISZERO16 B,C            ; returns 0 if not equal, 1 if equal
    ; jr z, ZE1
    _if nz
        ld BC, -1
    _endif
    inc BC
    NEXT

; and    x1 x2 -- x3            logical and
defcode "AND",3,0,and	        ; bitwise and
    POP_PAR0 HL
    ld A,b
    and H
    ld B,A
    ld A,C
    and L
    ld C,A
    NEXT

; INVERT x1 -- x2               ; bitwise complement
defcode "INVERT",6,0,INVERT
    ld A,B
    cpl
    ld B,A
    ld A,C
    cpl
    ld C,A
    NEXT

; TRUE
defcode "TRUE",4,0,TRUE
    PUSH_PAR0 BC
    ld BC,1
    NEXT

; LSHIFT  x1 u -- x2       logical L shift u places
defcode "LSHIFT",6,0,LSHIFT
    POP_PAR0 HL              ;   NB: hi 8 bits ignored!
    ld B,C              ; b = loop counter
    inc B               ; test for counter=0 case
    jr LSHIFT2
LSHIFT1:   add HL,HL        ; left shift HL, n times
LSHIFT2:   djnz LSHIFT1

    LOAD16 B,C, H,L     ; result is new TOS
    NEXT

; =      x1 x2 -- flag         test x1=x2
defcode "=",1,0,EQUALS
    POP_PAR0 HL
    or A
    sbc HL,BC       ; x1-x2 in HL, SZVC valid
    jr z,EQ1
    ld BC, 1       ;   if -ve, result true
EQ1:
    inc BC
    NEXT

; <      n1 n2 -- flag          test n1<n2
defcode "<",1,0,LESSTHAN	        ; less than
    POP_PAR0 HL
    or A
    sbc HL,BC       ; n1-n2 in HL, SZVC valid
    ; jp pe,revsense  ; if OV, use rev. sense
    _if pe
        ; jp m,tosfalse ; OV: if -ve, reslt false
        ; jr tostrue      ;     if +ve, result true
        _if m
            ld bc, 0
        _else
            ld bc, 1       ;   if -ve, result true
        _endif
    _else
        ; jp p,tosfalse   ;   if +ve, result false
        ; jp tostrue
        _if p
            ld bc, 0
        _else
            ld bc, 1       ;   if -ve, result true
        _endif
    _endif
    NEXT

; >      n1 n2 -- flag          test n1 > n2
defcode ">",1,0,GREATERTHAN	        ; less than
    POP_PAR0 HL                  ; swap operands
    PUSH_PAR H,L
    jr LESSTHAN

; OR    x1 x2 -- x3             logical OR
defcode "OR",2,0,OR	            ; bitwise OR
    POP_PAR0 HL
    ld A,B
    or H
    ld B,A
    ld A,C
    or L
    ld C,A
    NEXT

; xor    x1 x2 -- x3            logical xor
defcode "XOR",3,0,xor	        ; bitwise xor
    POP_PAR0 HL
    ld A,B
    xor H
    ld B,A
    ld A,C
    xor L
    ld C,A
    NEXT

; FALSE
defcode "FALSE",5,0,FALSE
    PUSH_PAR0 BC
    ld BC,0
    NEXT

;RSHIFT  x1 u -- x2    logical R shift u places
defcode "RSHIFT",6,0,RSHIFT
    POP_PAR0 HL        ;   NB: hi 8 bits ignored!
    ld B,C        ; b = loop counter
    inc B         ; test for counter=0 case
    jr RSHIFT2
RSHIFT1:   srl H         ; right shift HL, n times
    rr L
RSHIFT2:   djnz RSHIFT1
    LOAD16 B,C, H,L     ; result is new TOS
    NEXT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; stack
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


defcode "DUP",3,0,DUP        ; x -- x x
    PUSH_PAR0 BC
    NEXT

; SWAP     x1 x2 -- x2 x1    swap top two items
defcode "SWAP",4,0,SWAP      ; x1 x2 -- x2 x1
    POP_PAR0 hl
    PUSH_PAR H,L
    NEXT

defcode "ROT",3,0,ROT        ; x1 x2 x3 -- x2 x3 x1
    POP_PAR0 HL              ; x2 in HL
    ex (SP),HL          ; x2 on stack, x1 in HL
    PUSH_PAR H, L       ; PUSH x1
    NEXT

defcode "-ROT",4,0,NROT     ; x1 x2 x3 -- x3 x1 x2
    POP_PAR H, L        ; x3 in HL, x2 in BC
    ex (SP),HL          ; x3 on stack, x1 in HL
    PUSH_PAR0 HL             ; x3 x1 on stack, BC = x2
    NEXT

; >R    ( x -- ) ( R: -- x )  Move  x from TOS to the return stack.
defcode ">R",2,0,TO_R
    PUSH_RET B,C
    POP_PAR0 BC
    NEXT

; R@ r-fetch

defcode "DROP",4,0,DROP      ; x --
    POP_PAR0 BC		    ; drop top of stack
    NEXT

; OVER    x1 x2 -- x1 x2 x1
defcode "OVER",4,0,OVER
    POP_PAR0 hl
    PUSH_PAR0 hl
    PUSH_PAR H,L
    NEXT

; R>    ( -- x ) ( R: x -- )  Move x from the return stack to TOS
defcode "R>",2,0,R_FROM
    PUSH_PAR0 BC
    POP_RET B,C
    NEXT

defcode "'",1,0,TICK                 ; ( -- addr ) PUSH code word ptr of following word
    jp LIT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; definitions
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; CREATE     addr len --       create new header from name
defcode "CREATE",6,0,CREATE  ; addr len --

    SAVE_REGS BC
    POP_PAR0 HL
	; Link pointer.
	ld DE, (VAR_HERE)	    ; DE point to the start of a new header
	ld A, (VAR_LATEST) 	    ; write ptr to previous word in header
    ld (DE), A
    inc DE
    ld A, (VAR_LATEST + 1)
    ld (DE), A
    inc DE

	; Length byte and the word itself.
	ld A, C		    ; Get the length of namw.
	ld (DE), A      ; write to length/flags field of header
    inc DE          ; HL = name, de = name field in header, BC = length
	ldir            ; copy BC bytes from (HL) to (DE)

	; Update LATEST and HERE.
	ld HL, (VAR_HERE)
	ld (VAR_LATEST), HL
	ld (VAR_HERE), DE

    RESTORE_REGS0
    NEXT

defcode "IMMEDIATE",9,MSK_IMMED,IMMEDIATE
    ld HL, (VAR_LATEST)                 ; get head of latest word
    inc HL                              ; point to flags byte
    inc HL
    ld a, MSK_IMMED
    xor (HL)                            ; toggle the IMMED bit.
    ld (HL),a
    NEXT


; DOES> does

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; device
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defcode "ACCEPT",6,0,ACCEPT              ; ( addr max -- len )
    SAVE_REGS DE                    ; max - up to 255
	POP_PAR0 HL                          ; addr
    call getline
    RESTORE_REGS BC                 ; TOS = len
    NEXT

defcode "KEY",3,0,KEY                ; ( -- c )
	call getKey
    ld b, 0
    ld c, a
    NEXT

defcode "EMIT",4,0,EMIT              ; print the character on the stack
	ld A, C                     ; (c -- )
	call putc
    POP_PAR0 BC                      ; clear stack
    NEXT

defcode "KEY?",4,0,QKEY              ; ( -- c )
	PUSH_PAR0 BC		                ; save TOS
	call inputReady
    ld BC, 1                    ; TOS = true
    jr nz, QKEY_DONE
    ld BC, 0                    ; TOS = false
QKEY_DONE:
    NEXT

defcode ".",1,0,DOT                 ; print top of stack in BASE
    call printNum
    POP_PAR0 BC
    NEXT
