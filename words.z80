;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; words
;;
;; Forth word defintions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defconst "version",7,0,VERSION,1
defconst "r0",2,0,RZ, RET_STACK
defconst "msk_immed",9,0,__MSK_IMMED,MSK_IMMED
defconst "msk_hidden",10,0,__MSK_HIDDEN,MSK_HIDDEN
defconst "msk_length",10,0,__MSK_LENGTH,MSK_LENGTH

defword "quit",4,0,QUIT
    ld SP, RET_STACK
    call INTERPRET        ; interpret the next word
    ret

defword "interpret",6,0,INTERPRET
    ld A, 0
    ld (VAR_INTP_STOP), A
    _do
        call interp                        ; interpret the next word
        ld A,(VAR_INTP_STOP)
        or A
    _until nz
    _enddo
    ret

defword ">cfa",4,0,TCFA
    call FORTH
    dw LIT
    dw 2
    dw PLUS
    dw COUNT
    dw LIT
    dw MSK_LENGTH
    dw AND
    dw PLUS
    dw EXIT
    ret

; COUNT extract string length from pascal string  ( ptr -- ptr+1 len )
defword "count",5,0,COUNT
    call FORTH
    dw DUP
    dw LIT
    dw 1
    dw PLUS            ; ( ptr -- ptr ptr+1)
    dw SWAP
    dw CFETCH                 ; ( ptr ptr+1 -- ptr+1 len)
    dw EXIT
    ret

; ALLOT                             ( n -- addr ) allocate n bytes of memory
defword "allot",5,0,ALLOT
    ld HL, (VAR_HERE)
    ppush0 H,L
    or A
    adc HL,BC                       ; adds n to HERE, old value of HERE left on stack
    ld (VAR_HERE),HL
    ppop0 B,C
    ret

; NEGATE  n1 -- n2                        negate n1
defword "negate",6,0,NEGATE
    call INVERT
    inc BC
    ret

; ABS   n -- u                      absolute value
defword "abs",3,0,ABS
    call DUP                      ; copy arg
    call ZEROLESS
    checkZeroWord B,C
    ppop0 B,C              ; POP new TOS
    _if nz
        call NEGATE               ; if signs differ then negate answer
    _endif
    ret

defword "*",1,0,STAR            ; u1 u2 -- ud
    call OVER
    call OVER                   ; dupe both args
    call ABS
    call SWAP
    call ABS                    ; remove sign from both args
    call USTAR
    call DROP                   ; unsigned multiply, drop hi-word
    call NROT                   ; move to bottom
    call XOR                    ; zero if signs are the same
    call ZEROLESS               ; if high bit set
    checkZeroWord B,C
    ppop0 B,C              ; POP new TOS
    _if nz
        call NEGATE               ; if signs differ then negate answer
    _endif
    ret

defword "/mod",4,0,SLASHMOD       ; dvend dvisr -- rem quot
    call OVER
    call OVER                    ;       u1 u2 -- u1 u2 u1 u2  dupe both args
    call XOR                  ; u1 u2 u1 u2 -- u1 u2 b1     xor hi bits
    call ZEROLESS             ; true if high bit still set
    call NROT                 ;    u1 u2 b1 -- b1 u1 u2     move to bottom

    call OVER                 ;    b1 u1 u2 -- b1 u1 u2 u1  dupe dividend
    call ZEROLESS             ; b1 u1 u2 u1 -- b1 u1 u2 b2  zero if signs are the same
    call NROT                 ; b1 u1 u2 b2 -- b1 b2 u1 u2  move to bottom

    call ABS
    call SWAP
    call ABS
    call SWAP                    ; remove sign from both args
    call USLASHMOD            ; b1 b2 u1 u2 -- b1 b2 r q    unsigned divide (remainder, quotient)
    call SWAP                 ; b1 b2 u1 u2 -- b1 b2 q r
    call ROT                  ; b1 b2 q r -- b1 q r b2      bring to top
    checkZeroWord B,C
    ppop0 B,C              ; POP new TOS
    _if nz
        call NEGATE           ;   b1 q r b2 -- b1 q -r      if -ve then negate answer
    _endif
    call NROT                 ;     b1 q -r -- -r b1 q     bring to top
    call SWAP                 ;     -r b1 q -- -r q b1      bring to top
    checkZeroWord B,C
    ppop0 B,C              ; POP new TOS
    _if nz
        call NEGATE           ;     -r q b1 -- -r -q       if signs differ then negate answer
    _endif
    ret

defword "/",1,0,SLASH       ; dvend dvisr -- quot
    call SLASHMOD
    call SWAP
    call DROP               ; drop remainder
    ret

defword "mod",3,0,MOD     ; dvend dvisr -- remainder
    call SLASHMOD
    call DROP                 ; drop quotient
    ret

; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;;
; ;; flow control
; ;;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword "if",2,MSK_IMMED,IF
    call FORTH
    DW LIT, ZBRANCH, COMMA              ; compile 0BRANCH
    DW HERE, FETCH, DUP, COMMA          ; compile HERE and also push on stack
    DW EXIT
    ret

defword "else",4,MSK_IMMED,ELSE
    call FORTH
    DW LIT, BRANCH, COMMA                ; definite branch to just over the false-part
    DW HERE, FETCH                        ; save HERE on stack
    DW LIT, 0, COMMA                    ; compile a dummy offset
    DW SWAP                                ; now back-fill the original (IF) offset
    DW THEN
    DW EXIT
    ret

defword "then",4,MSK_IMMED,THEN
    call FORTH
    DW DUP
    DW HERE, FETCH, SWAP, MINUS            ; calculate the offset from the address saved on the stack
    DW SWAP, STORE                        ; store the offset in the back-filled location
    DW EXIT
    ret

; BEGIN condition WHILE ... REPEAT

defword "begin",5,MSK_IMMED,BEGIN
    call FORTH
    DW HERE, FETCH                        ; save HERE on stack (HERE1)
    DW EXIT
    ret

defword "while",5,MSK_IMMED,WHILE
    call FORTH
    DW LIT, ZBRANCH, COMMA              ; compile branch on zero
    DW HERE, FETCH                        ; save HERE in stack (HERE2)
    DW LIT, 0, COMMA                    ; compile dummy offset
    DW EXIT
    ret

defword "repeat",6,MSK_IMMED,REPEAT
    call FORTH
    DW LIT, BRANCH, COMMA               ; compile branch
    DW SWAP                             ; TOS = HERE1
    DW HERE, FETCH, MINUS, COMMA        ; compile offset (HERE1 - HERE3)
    DW DUP
    DW HERE, FETCH, SWAP, MINUS            ; compile offset (HERE2 - HERE3)
    DW SWAP, STORE                      ; save offset in HERE2
    DW EXIT
    ret

; ; DO
; ; I
; ; AGAIN
; ; LOOP
; ; J
; ; UNTIL

defword ":",1,0,COLON
    call FORTH
    DW TOKEN                            ; Get the name of the new word
    DW CREATE                           ; CREATE the dictionary entry / header
    DW LIT, CALL_OPCODE, CCOMMA         ; write Z80 jp OPCODE to word
    DW LIT, FORTH, COMMA                ; Append FORTH  (the codeword).
    DW LATEST, FETCH, HIDDEN            ; Make the word hidden (see below for definition).
    DW RBRAC                            ; Go into compile mode.
    DW EXIT                             ; Return from the function.
    ret                                 ; Return from the function.

defword ";",1,MSK_IMMED,SEMICOLON
    call FORTH
    DW LIT, EXIT, COMMA                 ; Append EXIT (so the word will return).
    DW LIT, RET_OPCODE, CCOMMA          ; write Z80 jp OPCODE to word
    DW LATEST, FETCH, HIDDEN            ; Toggle hidden flag -- unhide the word (see below for definition).
    DW LBRAC                            ; Go back to IMMEDIATE mode.
    DW EXIT                             ; Return from the function.
    ret                                 ; Return from the function.

; CONSTANT   n --      define a Forth constant
defword "constant",8,0,CONSTANT         ; ( n -- ) get name from input
    call FORTH
    DW TOKEN                            ; read name
    DW CREATE                           ; create header
    DW LIT, CALL_OPCODE, CCOMMA         ; write Z80 jp OPCODE to word
    DW LIT, FORTH, COMMA                ; write addr FORTH to word
    DW LIT, LIT, COMMA                  ; write addr of LIT to word
    DW COMMA                            ; write TOS to word
    DW LIT, EXIT, COMMA                 ; write addr of LIT to word
    DW LIT, RET_OPCODE, CCOMMA          ; write Z80 jp OPCODE to word
    DW EXIT
    ret

defword "variable",8,0,VARIABLE              ; ( n -- ) get name from input
    call FORTH
    DW LIT, 1, CELLS, ALLOT                    ; allocate 1 word, push addr
    DW TOKEN                            ; read name
    DW CREATE                           ; create header
    DW LIT, CALL_OPCODE, CCOMMA         ; write Z80 jp OPCODE to word
    DW LIT, FORTH, COMMA                ; write addr FORTH to word
    DW LIT, LIT, COMMA                  ; write addr of LIT to word
    DW COMMA                            ; write addr of variable to word
    DW LIT, EXIT, COMMA                 ; write addr of LIT to word
    DW LIT, RET_OPCODE, CCOMMA          ; write Z80 jp OPCODE to word
    DW EXIT
    ret

; ; DOES> does

; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;;
; ;; device
; ;;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword "cr",2,0,CR                  ; ( -- )
    call printCR
    ret

defword "test1",5,0,TEST1                  ; ( -- )
    nop
    nop
    call FORTH
    dw LIT
    dw 1
    dw DUP
    dw DUP
    dw EXIT
    nop
    nop
    ret

defvar "pad",3,0,PAD, VAR_PAD
defvar "here",4,0,HERE, VAR_HERE
defvar "intp_stop",9,0,INTP_STOP, VAR_INTP_STOP
defvar "state",5,0,STATE, VAR_STATE
defvar "s0",2,0,SZ, VAR_SZ
defvar "base",4,0,BASE, VAR_BASE
defvar "latest",6,0,LATEST, VAR_LATEST
