;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; words
;;
;; Forth word defintions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defconst "version",7,0,VERSION,1
defconst "r0",2,0,RZ, RET_STACK
defconst "msk_immed",9,0,__MSK_IMMED,MSK_IMMED
defconst "msk_hidden",10,0,__MSK_HIDDEN,MSK_HIDDEN
defconst "msk_length",10,0,__MSK_LENGTH,MSK_LENGTH

defword "quit",4,0,QUIT
    ld SP, RET_STACK
    call INTERPRET        ; interpret the next word
    ret

defword "interpret",6,0,INTERPRET
    ld A, 0
    ld (VAR_INTP_STOP), A
    _do
        call interp                        ; interpret the next word
        ld A,(VAR_INTP_STOP)
        or A
    _until nz
    _enddo
    ret

defword ">cfa",4,0,TCFA
    call LIT
    dw 2
    call PLUS
    call COUNT
    call LIT
    dw MSK_LENGTH
    call AND
    call PLUS
    ret

; COUNT extract string length from pascal string  ( ptr -- ptr+1 len )
defword "count",5,0,COUNT
    call DUP
    call LIT
    dw 1
    call PLUS            ; ( ptr -- ptr ptr+1)
    call SWAP
    call CFETCH                 ; ( ptr ptr+1 -- ptr+1 len)
    ret

; ALLOT                             ( n -- addr ) allocate n bytes of memory
defword "allot",5,0,ALLOT
    ld HL, (VAR_HERE)
    ppush0 H,L
    or A
    adc HL,BC                       ; adds n to HERE, old value of HERE left on stack
    ld (VAR_HERE),HL
    ppop0 B,C
    ret

; NEGATE  n1 -- n2                        negate n1
defword "negate",6,0,NEGATE
    call INVERT
    inc BC
    ret

; ABS   n -- u                      absolute value
defword "abs",3,0,ABS
    call DUP                      ; copy arg
    call ZEROLESS
    checkZeroWord B,C
    ppop0 B,C              ; POP new TOS
    _if nz
        call NEGATE               ; if signs differ then negate answer
    _endif
    ret

defword "*",1,0,STAR            ; u1 u2 -- ud
    call OVER
    call OVER                   ; dupe both args
    call ABS
    call SWAP
    call ABS                    ; remove sign from both args
    call USTAR
    call DROP                   ; unsigned multiply, drop hi-word
    call NROT                   ; move to bottom
    call XOR                    ; zero if signs are the same
    call ZEROLESS               ; if high bit set
    checkZeroWord B,C
    ppop0 B,C              ; POP new TOS
    _if nz
        call NEGATE               ; if signs differ then negate answer
    _endif
    ret

defword "/mod",4,0,SLASHMOD       ; dvend dvisr -- rem quot
    call OVER
    call OVER                    ;       u1 u2 -- u1 u2 u1 u2  dupe both args
    call XOR                  ; u1 u2 u1 u2 -- u1 u2 b1     xor hi bits
    call ZEROLESS             ; true if high bit still set
    call NROT                 ;    u1 u2 b1 -- b1 u1 u2     move to bottom

    call OVER                 ;    b1 u1 u2 -- b1 u1 u2 u1  dupe dividend
    call ZEROLESS             ; b1 u1 u2 u1 -- b1 u1 u2 b2  zero if signs are the same
    call NROT                 ; b1 u1 u2 b2 -- b1 b2 u1 u2  move to bottom

    call ABS
    call SWAP
    call ABS
    call SWAP                    ; remove sign from both args
    call USLASHMOD            ; b1 b2 u1 u2 -- b1 b2 r q    unsigned divide (remainder, quotient)
    call SWAP                 ; b1 b2 u1 u2 -- b1 b2 q r
    call ROT                  ; b1 b2 q r -- b1 q r b2      bring to top
    checkZeroWord B,C
    ppop0 B,C              ; POP new TOS
    _if nz
        call NEGATE           ;   b1 q r b2 -- b1 q -r      if -ve then negate answer
    _endif
    call NROT                 ;     b1 q -r -- -r b1 q     bring to top
    call SWAP                 ;     -r b1 q -- -r q b1      bring to top
    checkZeroWord B,C
    ppop0 B,C              ; POP new TOS
    _if nz
        call NEGATE           ;     -r q b1 -- -r -q       if signs differ then negate answer
    _endif
    ret

defword "/",1,0,SLASH       ; dvend dvisr -- quot
    call SLASHMOD
    call SWAP
    call DROP               ; drop remainder
    ret

defword "mod",3,0,MOD     ; dvend dvisr -- remainder
    call SLASHMOD
    call DROP                 ; drop quotient
    ret

; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;;
; ;; flow control
; ;;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword "if",2,MSK_IMMED,IF
    ld HL,(VAR_HERE)

    ld A,CALL_OPCODE                    ; write call ZBRANCH with value TOS
    writeByte HL, A

    push DE
    ld DE, ZBRANCH
    writeWord HL, D,E
    pop DE

    ppush H,L                           ; TOS = HERE
    writeWord HL, B,C                   ; write HERE

    ld (VAR_HERE),HL
    ret

defword "else",4,MSK_IMMED,ELSE
    ld HL,(VAR_HERE)
    ld A,CALL_OPCODE                    ; write call BRANCH
    writeByte HL, A

    push DE
    ld DE, BRANCH
    writeWord HL, D,E
    ppush0 H,L                          ; save HERE on stack under TOS
    ld DE,0                             ; write bogus offset for branch
    writeWord HL, D,E
    pop DE

    ld (VAR_HERE),HL
    jp THEN

defword "then",4,MSK_IMMED,THEN
    ld HL,(VAR_HERE)

    push DE
    ppop D,E
    or A
    sbc HL,DE
    ex DE,HL
    writeWord HL, D,E
    pop DE

    ret

; BEGIN condition WHILE ... REPEAT

defword "begin",5,MSK_IMMED,BEGIN
    ld HL,(VAR_HERE)                    ; save HERE on stack (HERE1)
    ppush H,L
    ret

defword "while",5,MSK_IMMED,WHILE
    ld HL,(VAR_HERE)
    ld A,CALL_OPCODE                    ; write call BRANCH
    writeByte HL, A

    push DE
    ld DE, ZBRANCH
    writeWord HL, D,E

    ppush H,L                           ; save HERE on stack under TOS

    ld DE,0                             ; write bogus offset for branch
    writeWord HL, D,E
    pop DE

    ld (VAR_HERE),HL
    ret

defword "repeat",6,MSK_IMMED,REPEAT
    ld HL,(VAR_HERE)
    ld A,CALL_OPCODE                    ; write call BRANCH
    writeByte HL, A

    push DE
    ld DE, BRANCH
    writeWord HL, D,E

    ppop0 D,E
    ex DE,HL
    or A
    sbc HL,DE
    ex DE,HL
    writeWord HL, D,E
    ld (VAR_HERE),HL

    loadWord D,E,B,C                    ; bc = herex, de = herex
    or A
    sbc HL,DE                           ; hl = diff
    ex DE,HL                            ; de = diff, hl = herex
    writeWord HL, D,E                   ; write diff to herex
    pop DE

    ppop0 B,C                           ; clear TOS
    ret

; ; DO
; ; I
; ; AGAIN
; ; LOOP
; ; J
; ; UNTIL

defword ":",1,0,COLON
    call TOKEN                          ; read name
    call CREATE                         ; create header
    ld BC,(VAR_LATEST)
    call HIDDEN                         ; Make the word hidden (see below for definition).
    call RBRAC                    ; Go into compile mode.
    ret                        ; Return from the function.

defword ";",1,MSK_IMMED,SEMICOLON
    ld HL,(VAR_HERE)
    ld A,RET_OPCODE                     ; write ret
    writeByte HL, A
    ld (VAR_HERE),HL

    ld BC,(VAR_LATEST)
    call HIDDEN                         ; Make the word hidden (see below for definition).
    call LBRAC                    ; Go into compile mode.

    ret                                 ; Return from the function.

; CONSTANT   n --      define a Forth constant
defword "constant",8,0,CONSTANT         ; ( n -- ) get name from input
    call TOKEN                          ; read name
    call CREATE                         ; create header
    ld HL,(VAR_HERE)
    ld A,CALL_OPCODE                    ; write call LIT with value TOS
    writeByte HL, A

    push DE
    ld DE, LIT
    writeWord HL, D,E
    pop DE

    writeWord HL, B,C                   ; write TOS
    ld A,RET_OPCODE                     ; write ret
    writeByte HL, A
    ld (VAR_HERE),HL
    ppop0 B,C                           ; clear TOS
    ret

defword "variable",8,0,VARIABLE              ; ( n -- ) get name from input
    ld BC, 2
    call ALLOT
    call TOKEN                          ; read name
    call CREATE                         ; create header
    ld HL,(VAR_HERE)
    ld A,CALL_OPCODE                    ; write call LIT with value var address
    writeByte HL, A

    push DE
    ld DE, LIT
    writeWord HL, D,E
    pop DE

    writeWord HL, B,C                   ; write addr of variable to word
    ld A,RET_OPCODE                     ; write ret
    writeByte HL, A
    ld (VAR_HERE),HL
    ppop0 B,C                           ; clear TOS
    ret

; ; DOES> does

; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;;
; ;; device
; ;;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword "cr",2,0,CR                  ; ( -- )
    call printCR
    ret

defvar "pad",3,0,PAD, VAR_PAD
defvar "here",4,0,HERE, VAR_HERE
defvar "intp_stop",9,0,INTP_STOP, VAR_INTP_STOP
defvar "state",5,0,STATE, VAR_STATE
defvar "s0",2,0,SZ, VAR_SZ
defvar "base",4,0,BASE, VAR_BASE
defvar "latest",6,0,LATEST, VAR_LATEST
