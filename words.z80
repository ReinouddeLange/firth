;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; words
;;
;; Forth word defijntions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


COLD:
        DW QUIT                     ; headerless word which never terminates

defconst "version",7,0,VERSION,1
defconst "r0",2,0,RZ, RET_STACK
defconst "docolon",7,0, __DOCOL,DOCOLON
defconst "msk_immed",9,0,__MSK_IMMED,MSK_IMMED
defconst "msk_hidden",10,0,__MSK_HIDDEN,MSK_HIDDEN
defconst "msk_length",10,0,__MSK_LENGTH,MSK_LENGTH

defword "quit",4,0,QUIT
    DW RZ,RSPSTORE        ; reset the return stack R0 RSP!
    DW INTERPRET        ; interpret the next word

StackPrompt: db '=> '

defword "interpret",6,0,INTERPRET
    DW LIT, 0
    DW INTP_STOP, STORE
    cDO
        DW interp                        ; interpret the next word
        DW CR
        DW LIT, StackPrompt, LIT, 3, TYPE
        DW DOTS, CR
        DW INTP_STOP, FETCH
    cUNTIL
    cENDDO
    DW EXIT

defword "interp",6,0,interp
    DW TOKEN                        ; ( -- ptr len)
    DW DUP, ZEQUAL
    cIf
                                    ; INTP_STOPPING:
        DW DROP, DROP                   ; (ptr len -- )
        DW LIT, 1
        DW LIT, VAR_INTP_STOP, STORE    ; VAR_INTP_STOP = 1
        DW EXIT
    cEndIf
    DW OVER, OVER, FIND             ; ( ptr len -- ptr len headPtrOrZero )
    DW DUP
    cIf
        DW SWAP, DROP, SWAP, DROP       ; ( ptr len headPtr -- headPtr ) found

        DW DUP, LIT, 2, PLUS, CFETCH    ; ( headPtr -- headPtr flags ) add 2 to headPtr
        DW LIT, MSK_IMMED, AND          ; ( headPtr flags -- headPtr immedFlag )
        DW ZEQUAL
        cIf
            DW LIT, VAR_STATE, FETCH        ; (headPtr -- headPtr state), if state = 1 compile
            cIf
                DW TCFA, COMMA                  ; compile headPtr
                DW EXIT
            cEndIf
        cEndIf
        DW TCFA, EXECUTE                ; execute headPtr
        DW EXIT
    cEndIf
    DW DROP                         ; ( ptr len zero -- ptr len ), not found

    DW NUMBER                       ; ( ptr len -- val err )
    cIf
        DW DROP                         ; ( ptr len zero -- ptr len ), not found
        DW LIT, TXT_ERROR               ; err != 0, parse error
        DW PRINT
        DW EXIT
    cEndIf
    DW LIT, VAR_STATE, FETCH        ; (val -- val state)
    cIf
        DW LIT, LIT                     ; (val -- val "LIT" )
        DW COMMA, COMMA                 ; compile "LIT" val
    cEndIf
    DW EXIT


defword ">cfa",4,0,TCFA
    DW LIT, 2, PLUS
    DW COUNT
    DW LIT, MSK_LENGTH, AND
    DW PLUS
    DW EXIT

; COUNT extract string length from pascal string  ( ptr -- ptr+1 len )
defword "count",5,0,COUNT
    DW DUP, LIT, 1, PLUS            ; ( ptr -- ptr ptr+1)
    DW SWAP, CFETCH                 ; ( ptr ptr+1 -- ptr+1 len)
    DW EXIT

; ALLOT                             ( n -- addr ) allocate n bytes of memory
defword "allot",5,0,ALLOT
    DW HERE, FETCH, SWAP        ; here n
    DW HERE, ADDSTORE                    ; adds n to HERE, old value of HERE left on stack
    DW EXIT

; NEGATE  n1 -- n2                        negate n1
defword "negate",6,0,NEGATE
    DW INVERT
    DW ONEPLUS
    DW EXIT

; ABS   n -- u                      absolute value
defword "abs",3,0,ABS
    DW DUP                      ; copy arg
    DW ZEROLESS
    cIf
        DW NEGATE               ; if signs differ then negate answer
    cEndIf
    DW EXIT

defword "*",1,0,STAR        ; u1 u2 -- ud
    DW OVER, OVER           ; dupe both args
    DW ABS, SWAP, ABS       ; remove sign from both args
    DW USTAR, DROP          ; unsigned multiply, drop hi-word
    DW NROT                 ; move to bottom
    DW XOR                  ; zero if signs are the same
    DW ZEROLESS             ; if high bit set
    cIf
        DW NEGATE           ; if signs differ then negate answer
    cEndIf
    DW EXIT

defword "/mod",4,0,SLASHMOD       ; dvend dvisr -- rem quot
    DW OVER, OVER           ;       u1 u2 -- u1 u2 u1 u2  dupe both args
    DW XOR                  ; u1 u2 u1 u2 -- u1 u2 b1     xor hi bits
    DW ZEROLESS             ; true if high bit still set
    DW NROT                 ;    u1 u2 b1 -- b1 u1 u2     move to bottom

    DW OVER                 ;    b1 u1 u2 -- b1 u1 u2 u1  dupe dividend
    DW ZEROLESS             ; b1 u1 u2 u1 -- b1 u1 u2 b2  zero if signs are the same
    DW NROT                 ; b1 u1 u2 b2 -- b1 b2 u1 u2  move to bottom

    ; DW DOT, DOT, DOT, DOT, CR  ; u2=-20 u1=-101 b2=1 b1=0

    DW ABS, SWAP, ABS, SWAP ; remove sign from both args
    DW USLASHMOD            ; b1 b2 u1 u2 -- b1 b2 r q    unsigned divide (remainder, quotient)
    DW SWAP                 ; b1 b2 u1 u2 -- b1 b2 q r
    DW ROT                  ; b1 b2 q r -- b1 q r b2      bring to top
    cIf
        DW NEGATE           ;   b1 q r b2 -- b1 q -r      if -ve then negate answer
    cEndIf
    DW NROT                 ;     b1 q -r -- -r b1 q     bring to top
    DW SWAP                 ;     -r b1 q -- -r q b1      bring to top
    cIf
        DW NEGATE           ;     -r q b1 -- -r -q       if signs differ then negate answer
    cEndIf
    DW EXIT

defword "/",1,0,SLASH       ; dvend dvisr -- quot
    DW SLASHMOD
    DW SWAP, DROP           ; drop remainder
    DW EXIT

defword "mod",3,0,MOD     ; dvend dvisr -- remainder
    DW SLASHMOD
    DW DROP                 ; drop quotient
    DW EXIT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; flow control
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword "if",2,MSK_IMMED,IF
    DW LIT, ZBRANCH, COMMA              ; compile 0BRANCH
    DW HERE, FETCH, DUP, COMMA          ; compile HERE and also push on stack
    DW EXIT

defword "then",4,MSK_IMMED,THEN
    DW DUP
    DW HERE, FETCH, SWAP, MINUS            ; calculate the offset from the address saved on the stack
    DW SWAP, STORE                        ; store the offset in the back-filled location
    DW EXIT

defword "else",4,MSK_IMMED,ELSE
    DW LIT, BRANCH, COMMA                ; definite branch to just over the false-part
    DW HERE, FETCH                        ; save HERE on stack
    DW LIT, 0, COMMA                    ; compile a dummy offset
    DW SWAP                                ; now back-fill the original (IF) offset
    DW THEN
    DW EXIT

; BEGIN condition WHILE ... REPEAT

defword "begin",5,MSK_IMMED,BEGIN
    DW HERE, FETCH                        ; save HERE on stack (HERE1)
    DW EXIT

defword "while",5,MSK_IMMED,WHILE
    DW LIT, ZBRANCH, COMMA              ; compile branch on zero
    DW HERE, FETCH                        ; save HERE in stack (HERE2)
    DW LIT, 0, COMMA                    ; compile dummy offset
    DW EXIT

defword "repeat",6,MSK_IMMED,REPEAT
    DW LIT, BRANCH, COMMA               ; compile branch
    DW SWAP                             ; TOS = HERE1
    DW HERE, FETCH, MINUS, COMMA        ; compile offset (HERE1 - HERE3)
    DW DUP
    DW HERE, FETCH, SWAP, MINUS            ; compile offset (HERE2 - HERE3)
    DW SWAP, STORE                      ; save offset in HERE2
    DW EXIT

; DO
; I
; AGAIN
; LOOP
; J
; UNTIL

defword ":",1,0,COLON
    DW TOKEN                    ; Get the name of the new word
    DW CREATE                    ; CREATE the dictionary entry / header
    DW LIT, JP_OPCODE, CCOMMA                ; write Z80 jp OPCODE to word
    DW LIT, DOCOLON, COMMA        ; Append DOCOLON  (the codeword).
    DW LATEST, FETCH, HIDDEN    ; Make the word hidden (see below for definition).
    DW RBRAC                    ; Go into compile mode.
    DW EXIT                        ; Return from the function.

; CONSTANT   n --      define a Forth constant
defword "constant",8,0,CONSTANT              ; ( n -- ) get name from input
    DW TOKEN                            ; read name
    DW CREATE                           ; create header
    DW LIT, JP_OPCODE, CCOMMA                ; write Z80 jp OPCODE to word
    DW LIT, DOCOLON, COMMA                ; write addr DOCOLON to word
    DW LIT, LIT, COMMA                  ; write addr of LIT to word
    DW COMMA                            ; write TOS to word
    DW LIT, EXIT, COMMA                  ; write addr of LIT to word
    DW EXIT

defword ";",1,MSK_IMMED,SEMICOLON
    DW LIT, EXIT, COMMA            ; Append EXIT (so the word will return).
    DW LATEST, FETCH, HIDDEN    ; Toggle hidden flag -- unhide the word (see below for definition).
    DW LBRAC                    ; Go back to IMMEDIATE mode.
    DW EXIT                        ; Return from the function.

defword "variable",8,0,VARIABLE              ; ( n -- ) get name from input
    DW LIT, 1, CELLS, ALLOT                    ; allocate 1 word, push addr
    DW TOKEN                            ; read name
    DW CREATE                           ; create header
    DW LIT, JP_OPCODE, CCOMMA                ; write Z80 jp OPCODE to word
    DW LIT, DOCOLON, COMMA             ; write addr DOCOLON to word
    DW LIT, LIT, COMMA                  ; write addr of LIT to word
    DW COMMA                            ; write addr of variable to word
    DW LIT, EXIT, COMMA                 ; write addr of LIT to word
    DW EXIT

; DOES> does

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; device
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword "cr",2,0,CR                  ; ( -- )
    DW LIT                      ; emit cr lf
    DB "\n", 0
    DW LIT
    DB "\r", 0
    DW EMIT
    DW EMIT
    DW EXIT

defvar "here",4,0,HERE, VAR_HERE
defvar "intp_stop",9,0,INTP_STOP, VAR_INTP_STOP
defvar "state",5,0,STATE, VAR_STATE
defvar "s0",2,0,SZ, VAR_SZ
defvar "base",4,0,BASE, VAR_BASE
defvar "latest",6,0,LATEST, VAR_LATEST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; tools
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

