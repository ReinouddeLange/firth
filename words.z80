;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; words
;;
;; forth word defintions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword "interpret",6,0,interpret
    rst $08
    cDo
    	dw lit, $20, word, count        ; pstr -- ptr len
        dw dup, zEqual
        cIf
            dw drop, drop                           ; ptr len --
            EXIT
        cEndif
        dw interpToken                       ; interpret the next word
    cEndDo
    EXIT

defword "interpToken",11,0,interpToken          ; ptr len --
    rst $08
    dw over, over, find                     ; ptr len -- ptr len addr
    dw dup, zNotEqual
    cIf
        dw interpWord
    cElse
        dw interpLiteral
    cEndif
    EXIT

interpWord:                                 ; ptr len addr --
    rst $08                                 ; enter forth
    dw swap, drop, swap, drop               ; ptr len addr -- addr
    dw dup, lit, 2, plus, cfetch            ; ( headptr -- headptr flags ) add 2 to headptr
    dw lit, msk_immed, and                  ; ( headptr flags -- headptr immedflag )
    dw zEqual
    cif
        dw tcfa                             ; ( headptr -- xt )
        dw state, fetch
        dw nesting, fetch
        dw or
        cif
            dw comma                        ; compile xt
        cElse
            dw execute                      ; execute xt
        cendif
    cElse
        dw tcfa, execute                    ; execute xt
    cendif
    EXIT

interpLiteral:                              ; ptr len addr --
    rst $08                                 ; enter forth
    dw drop                                 ; ptr len addr - ptr len
    dw number, zEqual                       ; parse to number
    cif
        dw state, fetch
        dw nesting, fetch
        dw or
        cIf
            dw lit, lit                     ; (val -- val "lit" )
            dw comma, comma                 ; compile "lit" val
        cEndIf
    cElse
        dw drop                             ; ( ptr len zero -- ptr len ), not found
        dw litstr                           ; err != 0, parse error
        .pstr "Error: parsing"
        dw type
    cEndIf
    EXIT


defword ">cfa",4,0,tcfa
    rst $08                             ; enter forth
    dw lit, 2, plus
    dw count
    dw lit, msk_length, and
    dw plus
    EXIT

; count extract string length from pascal string  ( ptr -- ptr+1 len )
defword "count",5,0,count
    rst $08                             ; enter forth
    dw dup, lit, 1, plus                ; ( ptr -- ptr ptr+1)
    dw swap, cfetch                     ; ( ptr ptr+1 -- ptr+1 len)
    EXIT

; allot                                 ( n -- addr ) allocate n bytes of memory
defword "allot",5,0,allot
    rst $08                             ; enter forth
    dw here, fetch, swap                ; here n
    dw here, addstore                   ; adds n to here, old value of here left on stack
    EXIT

; negate  n1 -- n2                      negate n1
defword "negate",6,0,negate
    rst $08                             ; enter forth
    dw invert
    dw oneplus
    EXIT

; abs   n -- u                          absolute value
defword "abs",3,0,ABS                   ; case sensitive for ABS label for some reason
    rst $08                             ; enter forth
    dw dup                              ; copy arg
    dw zeroless
    cif
        dw negate                       ; if signs differ then negate answer
    cendif
    EXIT

defword "*",1,0,star                    ; u1 u2 -- ud
    rst $08                             ; enter forth
    dw over, over                       ; dupe both args
    dw ABS, swap, ABS                   ; remove sign from both args
    dw ustar, drop                      ; unsigned multiply, drop hi-word
    dw nrot                             ; move to bottom
    dw xor                              ; zero if signs are the same
    dw zeroless                         ; if high bit set
    cif
        dw negate                       ; if signs differ then negate answer
    cendif
    EXIT

defword "/mod",4,0,slashmod             ; dvend dvisr -- rem quot
    rst $08                             ; enter forth
    dw over, over                       ;       u1 u2 -- u1 u2 u1 u2  dupe both args
    dw xor                              ; u1 u2 u1 u2 -- u1 u2 b1     xor hi bits
    dw zeroless                         ; true if high bit still set
    dw nrot                             ;    u1 u2 b1 -- b1 u1 u2     move to bottom

    dw over                             ;    b1 u1 u2 -- b1 u1 u2 u1  dupe dividend
    dw zeroless                         ; b1 u1 u2 u1 -- b1 u1 u2 b2  zero if signs are the same
    dw nrot                             ; b1 u1 u2 b2 -- b1 b2 u1 u2  move to bottom

    ; dw dot, dot, dot, dot, cr  ; u2=-20 u1=-101 b2=1 b1=0

    dw ABS, swap, ABS, swap             ; remove sign from both args
    dw uslashmod                        ; b1 b2 u1 u2 -- b1 b2 r q    unsigned divide (remainder, quotient)
    dw swap                             ; b1 b2 u1 u2 -- b1 b2 q r
    dw rot                              ; b1 b2 q r -- b1 q r b2      bring to top
    cif
        dw negate                       ;   b1 q r b2 -- b1 q -r      if -ve then negate answer
    cendif
    dw nrot                             ;     b1 q -r -- -r b1 q     bring to top
    dw swap                             ;     -r b1 q -- -r q b1      bring to top
    cif
        dw negate                       ;     -r q b1 -- -r -q       if signs differ then negate answer
    cendif
    EXIT

defword "/",1,0,slash                   ; dvend dvisr -- quot
    rst $08                             ; enter forth
    dw slashmod
    dw swap, drop                       ; drop remainder
    EXIT

defword "mod",3,0,mod                   ; dvend dvisr -- remainder
    rst $08                             ; enter forth
    dw slashmod
    dw drop                             ; drop quotient
    EXIT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; flow control
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword "if",2,msk_immed,if
    rst $08                             ; enter forth
    dw lbrace
    dw lit, zbranch, comma              ; compile 0branch
    dw here, fetch, dup, comma          ; compile here and also push on stack
    EXIT

defword "else",4,msk_immed,else
    rst $08                             ; enter forth
    dw lit, branch, comma               ; definite branch to just over the false-part
    dw here, fetch                      ; save here on stack
    dw lit, 0, comma                    ; compile a dummy offset
    dw swap                             ; now back-fill the original (if) offset
    dw xendif                           ; must call xendif not endif
    EXIT

defword "endif",5,msk_immed,endif
    rst $08                             ; enter forth
    dw xendif                           ; must call xendif not endif
    dw rbraceExec
    EXIT

xendif:                                 ; must call xendif not endif
    rst $08                             ; enter forth
    dw dup
    dw here, fetch, swap, minus         ; calculate the offset from the address saved on the stack
    dw swap, store                      ; store the offset in the back-filled location
    EXIT

; begin condition while ... repeat

defword "begin",5,msk_immed,begin
    rst $08                             ; enter forth
    dw lbrace
    dw here, fetch                      ; save here on stack (here1)
    EXIT

defword "while",5,msk_immed,while
    rst $08                             ; enter forth
    dw lit, zbranch, comma              ; compile branch on zero
    dw here, fetch                      ; save here in stack (here2)
    dw lit, 0, comma                    ; compile dummy offset
    EXIT

defword "repeat",6,msk_immed,repeat
    rst $08                             ; enter forth
    dw lit, branch, comma               ; compile branch
    dw swap                             ; tos = here1
    dw here, fetch, minus, comma        ; compile offset (here1 - here3)
    dw dup
    dw here, fetch, swap, minus         ; compile offset (here2 - here3)
    dw swap, store                      ; save offset in here2
    dw rbraceExec
    EXIT

; ; do
; ; i
; ; again
; ; loop
; ; j
; ; until

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; device
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword ".s",2,0,dots                   ; ( -- )
    rst $08                             ; enter forth
    dw spfetch
    dw sp0, fetch
    dw minus, zequal, zequal
    cif
        dw sp0, fetch, lit, 2, plus
        cdo
            dw dup
            dw spfetch, lit, 2, minus
            dw swap, minus, zequal
        cuntil
            dw dup, fetch, dot
            dw lit, 2, plus
        cenddo
        dw drop
    cendif
    EXIT

; using {"s",$27} because it's surprisingly difficult
; to define the name s' using asm80
defword {"s",$22},2,msk_immed,squote
    jr qt

defword $22,1,msk_immed,qt
    rst $08                             ; enter forth
    dw state, fetch, zequal
    cIf
        dw lit, $22                     ; delim
        dw lit, 63                      ; limit 63 + length
        dw latestStr, fetch
        dw lit, wordBuf, equal
        cIf
            dw lit, wordBuf2
        cElse
            dw lit, wordBuf
        cEndIf
        dw latestStr, store             ; store here in latestStr
        dw latestStr, fetch
        dw xword, count
    cElse
        dw lit, litstr, comma
        dw lit, $22, word
        dw cfetch, oneplus
        dw allot
    cEndif
    EXIT

defword {".",$22},2,msk_immed,dotquote
    rst $08                             ; enter forth
    dw qt
    dw state, fetch, zequal
    cIf
        dw type
    cElse
        dw lit, type, comma
    cEndIf
    EXIT

defword "decimal",7,0,decimal           ; pushes ptr to string and length on stack
    rst $08                             ; enter forth
    dw lit,10,base,store
    EXIT

defword "hex",3,0,hex                   ; pushes ptr to string and length on stack
    rst $08                             ; enter forth
    dw lit,16,base,store
    EXIT

defword "word",5,0,WORD                 ; delim -- c-addr
    rst $08                             ; enter forth
    dw lit, 64                          ; limit
    dw here, fetch
    dw xword                            ; writes to HERE!
    EXIT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Firth literal words (not in dictionary)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

litStr:                                 ; pushes ptr to string and length on stack
    rst $08                             ; enter forth
    dw rfrom
    dw count, over, over, plus
    dw tor
    EXIT

litIf:
    rst $08
    dw rfrom, dup
    dw lit, 4, plus, tor                ;
    dw swap
    cIf
        dw fetch
    cElse
        dw twoplus, fetch
    cEndif
    EXIT

litComma:                               ; pushes ptr to string and length on stack
    rst $08                             ; enter forth
    dw rfrom, dup
    dw lit, 2, plus, tor
    dw fetch, comma
    EXIT

litCComma:                              ; pushes ptr to string and length on stack
    rst $08                             ; enter forth
    dw rfrom, dup
    dw lit, 2, plus, tor
    dw fetch, cComma
    EXIT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; dictionary words
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword "create",6,0,create             ; --
    rst $08                             ; enter forth
    dw here, fetch                      ; get old "here"
    dw latest, fetch, comma             ; write link to previous word to "here"
    dw latest, store                    ; update latest to old "here"
    dw lit, $20, word                   ; read word token
    dw cfetch, oneplus, allot           ;
    dw lit, jp_opcode, cComma           ; compile default behavious
    dw lit, xcreate, comma              ; i.e. push addr of data area
    dw drop
    EXIT                                ; exit from forth
xcreate:
    rst $08                             ; enter forth
    dw rfrom                            ; push onto stack
    EXIT

defword "does>", 5, msk_immed, does
    rst $08                             ; enter forth
    dw lit, xdoes, comma
    dw lit, rst08_opcode                ; rst08
    dw here, fetch                      ; here
    dw cStore                           ; here    stored jp at here
    dw lit, 1, allot                    ; update here variable
    EXIT
xdoes:
    rst $08                             ; enter forth
    dw rfrom
    dw latest,fetch,tcfa
    dw lit, jp_opcode, over, cStore
    dw oneplus, store
    EXIT

defword ":",1,0,colon
    rst $08                             ; enter forth
    dw create                           ; create the dictionary entry / header
    dw here,fetch                       ; back up 3 bytes to start of data area
    dw lit, 3, minus
    dw here, store
    dw lit, rst08_opcode, ccomma        ; write z80 jp opcode to word
    dw latest, fetch, hidden            ; make the word hidden (see below for definition).
    dw rbrac                            ; go into compile mode.
    EXIT                                ; return from the function.

defword ";",1,msk_immed,semicolon
    rst $08                             ; enter forth
    dw lit, exit, comma                 ; append exit (so the word will return).
    dw latest, fetch, hidden            ; toggle hidden flag -- unhide the word (see below for definition).
    dw lbrac                            ; go back to immediate mode.
    EXIT                                ; return from the function.

defword ":noname",7,0,colonNoName
    rst $08                             ; enter forth
    dw here, fetch                      ; TOS = here
    dw lit, rst08_opcode, ccomma        ; write z80 jp opcode to word
    dw rbrac                            ; go into compile mode.
    EXIT                                ; return from the function.

defword "constant",8,0,constant             ; --
    rst $08                             ; enter forth
    dw create,comma,xdoes
    ppush H,L                           ; push address of data area
    rst $08                             ; enter forth
    dw lit, 3
    dw plus
    dw fetch
    EXIT

defword "variable",8,0,variable         ; ( n -- ) get name from input
    rst $08                             ; enter forth
    dw lit, 1, cells
    dw allot                            ; allocate n bytes, push addr
    dw constant
    EXIT

defword "buffer:",7,0,bufferColon       ; ( n -- ) get name from input
    rst $08                             ; enter forth
    dw allot                            ; allocate n bytes, push addr
    dw constant
    EXIT

defword "postpone",8,msk_immed,postpone ; --
    rst $08
	dw lit, $20, word, count            ; pstr -- ptr len
    dw dup, zEqual
    cIf
        dw drop, drop                   ; ptr len --
    cElse
        dw postponeToken                ; interpret the next word
    cEndif
    EXIT

postponeToken:                          ; --
    rst $08
    dw over, over, find                 ; ptr len -- ptr len addr
    dw dup, zNotEqual
    cIf
        dw postponeWord
    cElse
        dw postponeLiteral
    cEndif
    EXIT

postponeWord:                               ; ( headptr -- )
    rst $08                                 ; enter forth
    dw swap, drop, swap, drop               ; ptr len addr -- addr
    dw dup, lit, 2, plus, cfetch            ; ( headptr -- headptr flags ) add 2 to headptr
    dw lit, msk_immed, and                  ; ( headptr flags -- headptr immedflag )
    dw zEqual
    cIf
        dw lit, lit, comma
        dw tcfa, comma
        dw lit, comma, comma
    cElse
        dw tcfa, comma
    cEndIf
    EXIT

postponeLiteral:                            ; ( ptr len -- )
    rst $08                                 ; enter forth
    dw drop                                 ; ptr len addr - ptr len
    dw number, zEqual                       ; parse to number
    cif
        dw lit, lit                     ; (val -- val "lit" )
        dw comma, comma                 ; compile "lit" val
    cElse
        dw drop                             ; ( ptr len zero -- ptr len ), not found
        dw litstr                           ; err != 0, parse error
        .pstr "Error: parsing"
        dw type
    cEndIf
    EXIT
