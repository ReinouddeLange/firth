;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; words
;;
;; forth word defintions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defconst "version",7,0,version,1
defconst "r0",2,0,rz, ret_stack
defconst "msk_immed",9,0,__msk_immed,msk_immed
defconst "msk_hidden",10,0,__msk_hidden,msk_hidden
defconst "msk_length",10,0,__msk_length,msk_length

defword "quit",4,0,quit
    ld sp, ret_stack
    call interpret        ; interpret the next word
    ret

defword "interpret",6,0,interpret
    ld a, 0
    ld (var_intp_stop), a
    _do
        call interp                        ; interpret the next word
        ld a,(var_intp_stop)
        or a
    _until nz
    _enddo
    ret

defword ">cfa",4,0,tcfa
    call enter
    dw lit, 2, plus
    dw count
    dw lit, msk_length, and
    dw plus
    dw exit
    ret

; count extract string length from pascal string  ( ptr -- ptr+1 len )
defword "count",5,0,count
    call enter
    dw dup, lit, 1, plus            ; ( ptr -- ptr ptr+1)
    dw swap, cfetch                 ; ( ptr ptr+1 -- ptr+1 len)
    dw exit
    ret

; allot                             ( n -- addr ) allocate n bytes of memory
defword "allot",5,0,allot
    call enter
    dw here, fetch, swap        ; here n
    dw here, addstore                    ; adds n to here, old value of here left on stack
    dw exit
    ret

; negate  n1 -- n2                        negate n1
defword "negate",6,0,negate
    call enter
    dw invert
    dw oneplus
    dw exit
    ret

; abs   n -- u                      absolute value
defword "abs",3,0,ABS           ; case sensitive for ABS label for some reason
    call enter
    dw dup                      ; copy arg
    dw zeroless
    cif
        dw negate               ; if signs differ then negate answer
    cendif
    dw exit
    ret

defword "*",1,0,star            ; u1 u2 -- ud
    call enter
    dw over, over           ; dupe both args
    dw ABS, swap, ABS       ; remove sign from both args
    dw ustar, drop          ; unsigned multiply, drop hi-word
    dw nrot                 ; move to bottom
    dw xor                  ; zero if signs are the same
    dw zeroless             ; if high bit set
    cif
        dw negate           ; if signs differ then negate answer
    cendif
    dw exit
    ret

defword "/mod",4,0,slashmod       ; dvend dvisr -- rem quot
    call enter
    dw over, over           ;       u1 u2 -- u1 u2 u1 u2  dupe both args
    dw xor                  ; u1 u2 u1 u2 -- u1 u2 b1     xor hi bits
    dw zeroless             ; true if high bit still set
    dw nrot                 ;    u1 u2 b1 -- b1 u1 u2     move to bottom

    dw over                 ;    b1 u1 u2 -- b1 u1 u2 u1  dupe dividend
    dw zeroless             ; b1 u1 u2 u1 -- b1 u1 u2 b2  zero if signs are the same
    dw nrot                 ; b1 u1 u2 b2 -- b1 b2 u1 u2  move to bottom

    ; dw dot, dot, dot, dot, cr  ; u2=-20 u1=-101 b2=1 b1=0

    dw ABS, swap, ABS, swap ; remove sign from both args
    dw uslashmod            ; b1 b2 u1 u2 -- b1 b2 r q    unsigned divide (remainder, quotient)
    dw swap                 ; b1 b2 u1 u2 -- b1 b2 q r
    dw rot                  ; b1 b2 q r -- b1 q r b2      bring to top
    cif
        dw negate           ;   b1 q r b2 -- b1 q -r      if -ve then negate answer
    cendif
    dw nrot                 ;     b1 q -r -- -r b1 q     bring to top
    dw swap                 ;     -r b1 q -- -r q b1      bring to top
    cif
        dw negate           ;     -r q b1 -- -r -q       if signs differ then negate answer
    cendif
    dw exit
    ret

defword "/",1,0,slash       ; dvend dvisr -- quot
    call enter
    dw slashmod
    dw swap, drop           ; drop remainder
    dw exit
    ret

defword "mod",3,0,mod     ; dvend dvisr -- remainder
    call enter
    dw slashmod
    dw drop                 ; drop quotient
    dw exit
    ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; flow control
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword "if",2,msk_immed,if
    call enter
    dw lit, zbranch, comma              ; compile 0branch
    dw here, fetch, dup, comma          ; compile here and also push on stack
    dw exit
    ret

defword "else",4,msk_immed,else
    call enter
    dw lit, branch, comma                ; definite branch to just over the false-part
    dw here, fetch                        ; save here on stack
    dw lit, 0, comma                    ; compile a dummy offset
    dw swap                                ; now back-fill the original (if) offset
    dw endif
    dw exit
    ret

defword "endif",5,msk_immed,endif
    call enter
    dw dup
    dw here, fetch, swap, minus            ; calculate the offset from the address saved on the stack
    dw swap, store                        ; store the offset in the back-filled location
    dw exit
    ret

; begin condition while ... repeat

defword "begin",5,msk_immed,begin
    call enter
    dw here, fetch                        ; save here on stack (here1)
    dw exit
    ret

defword "while",5,msk_immed,while
    call enter
    dw lit, zbranch, comma              ; compile branch on zero
    dw here, fetch                        ; save here in stack (here2)
    dw lit, 0, comma                    ; compile dummy offset
    dw exit
    ret

defword "repeat",6,msk_immed,repeat
    call enter
    dw lit, branch, comma               ; compile branch
    dw swap                             ; tos = here1
    dw here, fetch, minus, comma        ; compile offset (here1 - here3)
    dw dup
    dw here, fetch, swap, minus            ; compile offset (here2 - here3)
    dw swap, store                      ; save offset in here2
    dw exit
    ret

; ; do
; ; i
; ; again
; ; loop
; ; j
; ; until

defword "create",7,0,create  ; --
    call enter
    dw nesting, fetch, zequal
    cIf
        dw here, fetch                      ; save old here
        dw latest, fetch, comma             ; write link to previous word to here
        dw latest, store                    ; update latest to old here
        dw lit, $20, word                  ; read word token
        dw cfetch, oneplus, allot           ; allocate string plus length byte
        dw drop
    cElse
        dw lit, nestingErr, count, type
    cEndIf
    dw exit                             ; exit from forth
    ret

defword ":",1,0,colon
    call enter
    dw create                           ; create the dictionary entry / header
    dw lit, call_opcode, ccomma         ; write z80 jp opcode to word
    dw lit, enter, comma                ; append forth  (the codeword).
    dw latest, fetch, hidden            ; make the word hidden (see below for definition).
    dw rbrac                            ; go into compile mode.
    dw exit                             ; return from the function.
    ret                                 ; return from the function.

defword ";",1,msk_immed,semicolon
    call enter
    dw lit, exit, comma                 ; append exit (so the word will return).
    dw lit, ret_opcode, ccomma          ; write z80 jp opcode to word
    dw latest, fetch, hidden            ; toggle hidden flag -- unhide the word (see below for definition).
    dw lbrac                            ; go back to immediate mode.
    dw exit                             ; return from the function.
    ret                                 ; return from the function.

; constant   n --      define a forth constant
defword "constant",8,0,constant         ; ( n -- ) get name from input
    call enter
    dw create                           ; create header
    dw lit, call_opcode, ccomma         ; write z80 jp opcode to word
    dw lit, enter, comma                ; write addr forth to word
    dw lit, lit, comma                  ; write addr of lit to word
    dw comma                            ; write tos to word
    dw lit, exit, comma                 ; write addr of lit to word
    dw lit, ret_opcode, ccomma          ; write z80 jp opcode to word
    dw exit
    ret

defword "variable",8,0,variable         ; ( n -- ) get name from input
    call enter
    dw lit, 1, cells
    dw allot                            ; allocate n bytes, push addr
    dw constant
    dw exit
    ret

defword "buffer:",7,0,buffercolon       ; ( n -- ) get name from input
    call enter
    dw allot                            ; allocate n bytes, push addr
    dw constant
    dw exit
    ret

; ; does> does

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; device
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword "cr",2,0,cr                  ; ( -- )
    call printcr
    ret

defword "test1",5,0,test1                  ; ( -- )
    nop
    nop
    call enter
    dw lit
    dw 1
    dw dup
    dw dup
    dw exit
    nop
    nop
    ret


defword ".s",2,0,dots                  ; ( -- )
    call enter
    dw spfetch
    dw sp0, fetch
    dw minus, zequal, zequal
    cif
        dw sp0, fetch, lit, 2, plus
        cdo
            dw dup
            dw spfetch, lit, 2, minus
            dw swap, minus, zequal
        cuntil
            dw dup, fetch, dot
            dw lit, 2, plus
        cenddo
        dw drop
    cendif
    dw exit
    ret

; using {"s",$27} because it's surprisingly difficult
; to define the name s' using asm80
defword {"s",$22},2,msk_immed,squote
    jr qt

defword $22,1,msk_immed,qt
    call enter
    dw state, fetch, zequal
    cIf
        dw lit, $22                     ; delim
        dw lit, 63                       ; limit 63 + length
        dw latestStr, fetch
        dw lit, wordBuf, equals
        cIf
            dw lit, wordBuf2
        cElse
            dw lit, wordBuf
        cEndIf
        dw latestStr, store         ; store here in latestStr
        dw latestStr, fetch
        dw xword, count
    cElse
        dw lit, litstr, comma
        dw lit, $22, word
        dw cfetch, oneplus
        dw allot
    cEndif
    dw exit
    ret

defword "litstr",6,0,litstr   ; pushes ptr to string and length on stack
    call enter
    dw rfrom
    dw count, over, over, plus
    dw tor
    dw exit
    ret

defword {".",$22},2,msk_immed,dotquote
    call enter
    dw qt
    dw state, fetch, zequal
    cIf
        dw type
    cElse
        dw lit, type, comma
    cEndIf
    dw exit
    ret

defword "decimal",7,0,decimal           ; pushes ptr to string and length on stack
    call enter
    dw lit,10,base,store
    dw EXIT
    ret

defword "hex",3,0,hex                   ; pushes ptr to string and length on stack
    call enter
    dw lit,16,base,store
    dw EXIT
    ret

defword "word",5,0,WORD                 ; delim -- c-addr
    call enter
    dw lit, 64
    dw here, fetch
    dw xword                            ; writes to HERE!
    dw exit
    ret

defword "xword",6,0,xword               ; delim limit addr -- c-addr
    call enter
    dw xwordSkip
    dw xwordRead
    dw exit
    ret

defvar "pad",3,0,pad, var_pad
defvar "here",4,0,here, var_here
defvar "intp_stop",9,0,intp_stop, var_intp_stop
defvar "state",5,0,state, var_state
defvar "nesting",5,0,nesting, var_nesting
defvar "sp0",3,0,sp0, var_sp0
defvar "base",4,0,base, var_base
defvar "latestStr",6,0,latestStr, var_latest_str
defvar "latest",6,0,latest, var_latest
