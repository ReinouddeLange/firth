;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; words
;;
;; Forth word defintions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defconst "version",7,0,VERSION,1
defconst "r0",2,0,RZ, RET_STACK
defconst "msk_immed",9,0,__MSK_IMMED,MSK_IMMED
defconst "msk_hidden",10,0,__MSK_HIDDEN,MSK_HIDDEN
defconst "msk_length",10,0,__MSK_LENGTH,MSK_LENGTH

defword "quit",4,0,QUIT
    ld SP, RET_STACK
    call INTERPRET        ; interpret the next word
    ret

defword "interpret",6,0,INTERPRET
    ld A, 0
    ld (VAR_INTP_STOP), A
    _do
        call interp                        ; interpret the next word
        ld A,(VAR_INTP_STOP)
        or A
    _until nz
    _enddo
    ret

defword ">cfa",4,0,TCFA
    call FORTH
    DW LIT, 2, PLUS
    DW COUNT
    DW LIT, MSK_LENGTH, AND
    DW PLUS
    DW EXIT
    ret

; COUNT extract string length from pascal string  ( ptr -- ptr+1 len )
defword "count",5,0,COUNT
    call FORTH
    DW DUP, LIT, 1, PLUS            ; ( ptr -- ptr ptr+1)
    DW SWAP, CFETCH                 ; ( ptr ptr+1 -- ptr+1 len)
    DW EXIT
    ret

; ALLOT                             ( n -- addr ) allocate n bytes of memory
defword "allot",5,0,ALLOT
    call FORTH
    DW HERE, FETCH, SWAP        ; here n
    DW HERE, ADDSTORE                    ; adds n to HERE, old value of HERE left on stack
    DW EXIT
    ret

; NEGATE  n1 -- n2                        negate n1
defword "negate",6,0,NEGATE
    call FORTH
    DW INVERT
    DW ONEPLUS
    DW EXIT
    ret

; ABS   n -- u                      absolute value
defword "abs",3,0,ABS
    call FORTH
    DW DUP                      ; copy arg
    DW ZEROLESS
    cIf
        DW NEGATE               ; if signs differ then negate answer
    cEndIf
    DW EXIT
    ret

defword "*",1,0,STAR            ; u1 u2 -- ud
    call FORTH
    DW OVER, OVER           ; dupe both args
    DW ABS, SWAP, ABS       ; remove sign from both args
    DW USTAR, DROP          ; unsigned multiply, drop hi-word
    DW NROT                 ; move to bottom
    DW XOR                  ; zero if signs are the same
    DW ZEROLESS             ; if high bit set
    cIf
        DW NEGATE           ; if signs differ then negate answer
    cEndIf
    DW EXIT
    ret

defword "/mod",4,0,SLASHMOD       ; dvend dvisr -- rem quot
    call FORTH
    DW OVER, OVER           ;       u1 u2 -- u1 u2 u1 u2  dupe both args
    DW XOR                  ; u1 u2 u1 u2 -- u1 u2 b1     xor hi bits
    DW ZEROLESS             ; true if high bit still set
    DW NROT                 ;    u1 u2 b1 -- b1 u1 u2     move to bottom

    DW OVER                 ;    b1 u1 u2 -- b1 u1 u2 u1  dupe dividend
    DW ZEROLESS             ; b1 u1 u2 u1 -- b1 u1 u2 b2  zero if signs are the same
    DW NROT                 ; b1 u1 u2 b2 -- b1 b2 u1 u2  move to bottom

    ; DW DOT, DOT, DOT, DOT, CR  ; u2=-20 u1=-101 b2=1 b1=0

    DW ABS, SWAP, ABS, SWAP ; remove sign from both args
    DW USLASHMOD            ; b1 b2 u1 u2 -- b1 b2 r q    unsigned divide (remainder, quotient)
    DW SWAP                 ; b1 b2 u1 u2 -- b1 b2 q r
    DW ROT                  ; b1 b2 q r -- b1 q r b2      bring to top
    cIf
        DW NEGATE           ;   b1 q r b2 -- b1 q -r      if -ve then negate answer
    cEndIf
    DW NROT                 ;     b1 q -r -- -r b1 q     bring to top
    DW SWAP                 ;     -r b1 q -- -r q b1      bring to top
    cIf
        DW NEGATE           ;     -r q b1 -- -r -q       if signs differ then negate answer
    cEndIf
    DW EXIT
    ret

defword "/",1,0,SLASH       ; dvend dvisr -- quot
    call FORTH
    DW SLASHMOD
    DW SWAP, DROP           ; drop remainder
    DW EXIT
    ret

defword "mod",3,0,MOD     ; dvend dvisr -- remainder
    call FORTH
    DW SLASHMOD
    DW DROP                 ; drop quotient
    DW EXIT
    ret

; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;;
; ;; flow control
; ;;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword "if",2,MSK_IMMED,IF
    call FORTH
    DW LIT, ZBRANCH, COMMA              ; compile 0BRANCH
    DW HERE, FETCH, DUP, COMMA          ; compile HERE and also push on stack
    DW EXIT
    ret

defword "else",4,MSK_IMMED,ELSE
    call FORTH
    DW LIT, BRANCH, COMMA                ; definite branch to just over the false-part
    DW HERE, FETCH                        ; save HERE on stack
    DW LIT, 0, COMMA                    ; compile a dummy offset
    DW SWAP                                ; now back-fill the original (IF) offset
    DW ENDIF
    DW EXIT
    ret

defword "endif",5,MSK_IMMED,ENDIF
    call FORTH
    DW DUP
    DW HERE, FETCH, SWAP, MINUS            ; calculate the offset from the address saved on the stack
    DW SWAP, STORE                        ; store the offset in the back-filled location
    DW EXIT
    ret

; BEGIN condition WHILE ... REPEAT

defword "begin",5,MSK_IMMED,BEGIN
    call FORTH
    DW HERE, FETCH                        ; save HERE on stack (HERE1)
    DW EXIT
    ret

defword "while",5,MSK_IMMED,WHILE
    call FORTH
    DW LIT, ZBRANCH, COMMA              ; compile branch on zero
    DW HERE, FETCH                        ; save HERE in stack (HERE2)
    DW LIT, 0, COMMA                    ; compile dummy offset
    DW EXIT
    ret

defword "repeat",6,MSK_IMMED,REPEAT
    call FORTH
    DW LIT, BRANCH, COMMA               ; compile branch
    DW SWAP                             ; TOS = HERE1
    DW HERE, FETCH, MINUS, COMMA        ; compile offset (HERE1 - HERE3)
    DW DUP
    DW HERE, FETCH, SWAP, MINUS            ; compile offset (HERE2 - HERE3)
    DW SWAP, STORE                      ; save offset in HERE2
    DW EXIT
    ret

; ; DO
; ; I
; ; AGAIN
; ; LOOP
; ; J
; ; UNTIL

defword "create1",7,0,CREATE1  ; --
    call FORTH
    dw HERE, FETCH                      ; save old here
    dw LATEST, FETCH, COMMA             ; write link to previous word to HERE
    dw LATEST, STORE                    ; update LATEST to old HERE
    dw LIT, $20, WORD1                  ; read word token
    dw CFETCH, ONEPLUS, ALLOT           ; allocate string plus length byte
    DW EXIT                             ; exit from Forth
    ret

defword ":",1,0,COLON
    call FORTH
    DW CREATE1                           ; CREATE the dictionary entry / header
    DW LIT, CALL_OPCODE, CCOMMA         ; write Z80 jp OPCODE to word
    DW LIT, FORTH, COMMA                ; Append FORTH  (the codeword).
    DW LATEST, FETCH, HIDDEN            ; Make the word hidden (see below for definition).
    DW RBRAC                            ; Go into compile mode.
    DW EXIT                             ; Return from the function.
    ret                                 ; Return from the function.

defword ";",1,MSK_IMMED,SEMICOLON
    call FORTH
    DW LIT, EXIT, COMMA                 ; Append EXIT (so the word will return).
    DW LIT, RET_OPCODE, CCOMMA          ; write Z80 jp OPCODE to word
    DW LATEST, FETCH, HIDDEN            ; Toggle hidden flag -- unhide the word (see below for definition).
    DW LBRAC                            ; Go back to IMMEDIATE mode.
    DW EXIT                             ; Return from the function.
    ret                                 ; Return from the function.

; CONSTANT   n --      define a Forth constant
defword "constant",8,0,CONSTANT         ; ( n -- ) get name from input
    call FORTH
    dw LIT, $20                         ; delim = space
    DW WORD                            ; read name
    DW CREATE                           ; create header
    DW LIT, CALL_OPCODE, CCOMMA         ; write Z80 jp OPCODE to word
    DW LIT, FORTH, COMMA                ; write addr FORTH to word
    DW LIT, LIT, COMMA                  ; write addr of LIT to word
    DW COMMA                            ; write TOS to word
    DW LIT, EXIT, COMMA                 ; write addr of LIT to word
    DW LIT, RET_OPCODE, CCOMMA          ; write Z80 jp OPCODE to word
    DW EXIT
    ret

defword "variable",8,0,VARIABLE              ; ( n -- ) get name from input
    call FORTH
    DW LIT, 1, CELLS, ALLOT                    ; allocate 1 word, push addr
    dw LIT, $20                         ; delim = space
    DW WORD                             ; read name
    DW CREATE                           ; create header
    DW LIT, CALL_OPCODE, CCOMMA         ; write Z80 jp OPCODE to word
    DW LIT, FORTH, COMMA                ; write addr FORTH to word
    DW LIT, LIT, COMMA                  ; write addr of LIT to word
    DW COMMA                            ; write addr of variable to word
    DW LIT, EXIT, COMMA                 ; write addr of LIT to word
    DW LIT, RET_OPCODE, CCOMMA          ; write Z80 jp OPCODE to word
    DW EXIT
    ret

; ; DOES> does

; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;;
; ;; device
; ;;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword "cr",2,0,CR                  ; ( -- )
    call printCR
    ret

defword "test1",5,0,TEST1                  ; ( -- )
    nop
    nop
    call FORTH
    dw LIT
    dw 1
    dw DUP
    dw DUP
    dw EXIT
    nop
    nop
    ret


defword ".s",2,0,DOTS                  ; ( -- )
    call FORTH
    dw SPFETCH
    dw SP0, FETCH
    dw MINUS, ZEQUAL, ZEQUAL
    cIF
        dw SP0, FETCH, LIT, 2, PLUS
        cDO
            dw DUP
            dw SPFETCH, LIT, 2, MINUS
            dw SWAP, MINUS, ZEQUAL
        cUNTIL
            dw DUP, FETCH, DOT
            dw LIT, 2, PLUS
        cENDDO
        dw DROP
    cENDIF
    dw EXIT
    ret

; using {"s",$27} because it's surprisingly difficult
; to define the name s' using asm80
defword {"s",$22},2,MSK_IMMED,SQUOTE
    call FORTH
    dw LIT, LITSTR, COMMA
    dw LIT, $22, WORD1
    dw CFETCH, ONEPLUS
    dw ALLOT
    dw EXIT
    ret

defword "litstr",6,0,LITSTR   ; pushes ptr to string and length on stack
    call FORTH
    dw RFROM
    dw COUNT, OVER, OVER, PLUS
    dw TOR
    dw EXIT
    ret

defword {".",$22},2,MSK_IMMED,DOTQUOTE
    call FORTH
    DW SQUOTE
    DW LIT,TYPE,COMMA
    DW EXIT
    ret

defvar "pad",3,0,PAD, VAR_PAD
defvar "here",4,0,HERE, VAR_HERE
defvar "intp_stop",9,0,INTP_STOP, VAR_INTP_STOP
defvar "state",5,0,STATE, VAR_STATE
defvar "sp0",3,0,SP0, VAR_SP0
defvar "base",4,0,BASE, VAR_BASE
defvar "latest",6,0,LATEST, VAR_LATEST
