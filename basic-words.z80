;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; words
;;
;; forth word defintions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword "'",1,0,tick                    ; quotes next word
    dw bl,word,find,zEqual
    dw rFrom,count,over,over,plus,toR
    dw EXIT

defword "decimal",7,0,decimal           ; pushes ptr to string and length on stack
    rst $08                             ; enter forth
    dw lit,10,base,store
    EXIT

defword "hex",3,0,hex                   ; pushes ptr to string and length on stack
    rst $08                             ; enter forth
    dw lit,16,base,store
    EXIT

; min   n1 n2 -- u                      minimum
defword "min",3,0,min
    rst $08
    dw over, over
    dw lessThan
    cif
        dw drop
    cElse
        dw swap, drop
    cendif
    EXIT

; max   n1 n2 -- u                      maximum
defword "max",3,0,max
    rst $08
    dw over, over
    dw lessThan
    cif
        dw swap, drop
    cElse
        dw drop
    cendif
    EXIT

defword "*",1,0,star                    ; u1 u2 -- ud
    rst $08                             ; enter forth
    dw over, over                       ; dupe both args
    dw ABS, swap, ABS                   ; remove sign from both args
    dw ustar, drop                      ; unsigned multiply, drop hi-word
    dw nrot                             ; move to bottom
    dw xor                              ; zero if signs are the same
    dw zeroless                         ; if high bit set
    cif
        dw negate                       ; if signs differ then negate answer
    cendif
    EXIT

defword "/mod",4,0,slashmod             ; dvend dvisr -- rem quot
    rst $08                             ; enter forth
    dw over, over                       ;       u1 u2 -- u1 u2 u1 u2  dupe both args
    dw xor                              ; u1 u2 u1 u2 -- u1 u2 b1     xor hi bits
    dw zeroless                         ; true if high bit still set
    dw nrot                             ;    u1 u2 b1 -- b1 u1 u2     move to bottom

    dw over                             ;    b1 u1 u2 -- b1 u1 u2 u1  dupe dividend
    dw zeroless                         ; b1 u1 u2 u1 -- b1 u1 u2 b2  zero if signs are the same
    dw nrot                             ; b1 u1 u2 b2 -- b1 b2 u1 u2  move to bottom

    dw ABS, swap, ABS, swap             ; remove sign from both args
    dw uslashmod                        ; b1 b2 u1 u2 -- b1 b2 r q    unsigned divide (remainder, quotient)
    dw swap                             ; b1 b2 u1 u2 -- b1 b2 q r
    dw rot                              ; b1 b2 q r -- b1 q r b2      bring to top
    cif
        dw negate                       ;   b1 q r b2 -- b1 q -r      if -ve then negate answer
    cendif
    dw nrot                             ;     b1 q -r -- -r b1 q     bring to top
    dw swap                             ;     -r b1 q -- -r q b1      bring to top
    cif
        dw negate                       ;     -r q b1 -- -r -q       if signs differ then negate answer
    cendif
    EXIT

defword "/",1,0,slash                   ; dvend dvisr -- quot
    rst $08                             ; enter forth
    dw slashmod
    dw swap, drop                       ; drop remainder
    EXIT

defword "mod",3,0,mod                   ; dvend dvisr -- remainder
    rst $08                             ; enter forth
    dw slashmod
    dw drop                             ; drop quotient
    EXIT

; ; do
; ; i
; ; again
; ; loop
; ; j
; ; until

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; device
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; .s print stack (non-destructively)
defword ".s",2,0,dots                   ; ( -- )
    rst $08                             ; enter forth
    dw spfetch                          ; psp
    dw sp0, fetch                       ; psp0
    dw minus
    dw lit, 0, greaterThan
    cif
        dw sp0, fetch, lit, 2, plus
        cdo
            dw dup
            dw spfetch, lit, 2, minus
            dw swap, minus, zequal
        cuntil
            dw dup, fetch, dot
            dw lit, 2, plus
        cenddo
        dw drop
    cendif
    EXIT

; ." print string"
defword {".",$22},2,msk_immed,dotquote
    rst $08                             ; enter forth
    dw qt
    dw state, fetch, zequal
    cIf
        dw type
    cElse
        dw lit, type, comma
    cEndIf
    EXIT

